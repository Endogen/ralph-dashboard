"""Unified CLI for installing and operating Ralph Dashboard."""

from __future__ import annotations

import argparse
import getpass
import os
import re
import secrets
import shutil
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from stat import S_IRUSR, S_IWUSR

from app.auth.service import hash_password
from app.auth.setup_user import write_credentials_file

DEFAULT_PORT = 8420
DEFAULT_CONFIG_DIR = Path.home() / ".config" / "ralph-dashboard"
DEFAULT_ENV_FILE = DEFAULT_CONFIG_DIR / "env"
DEFAULT_CREDENTIALS_FILE = DEFAULT_CONFIG_DIR / "credentials.yaml"
DEFAULT_PROJECT_DIRS = [Path.home() / "projects"]
DEFAULT_SERVICE_NAME = "ralph-dashboard"
MIN_PYTHON_VERSION = (3, 12)
ENV_SAFE_VALUE_RE = re.compile(r"^[A-Za-z0-9_./:\-]+$")
CHECK_MARK = "[OK]"
WARN_MARK = "[WARN]"
FAIL_MARK = "[FAIL]"


@dataclass(slots=True)
class CheckResult:
    name: str
    ok: bool
    message: str
    fix: str | None = None
    warning: bool = False

    @property
    def marker(self) -> str:
        if self.ok:
            return CHECK_MARK
        if self.warning:
            return WARN_MARK
        return FAIL_MARK


def repo_root() -> Path:
    """Resolve repository root from package source layout."""
    return Path(__file__).resolve().parents[3]


def backend_dir() -> Path:
    """Resolve backend project directory."""
    return repo_root() / "backend"


def default_packaged_frontend_dist() -> Path:
    """Resolve packaged frontend dist directory under backend/app/static."""
    return backend_dir() / "app" / "static" / "dist"


def default_dev_frontend_dist() -> Path:
    """Resolve development frontend dist directory under frontend/."""
    return repo_root() / "frontend" / "dist"


def parse_project_dirs(value: str) -> list[Path]:
    """Parse project roots from pathsep/comma-separated string."""
    raw_parts = value.split(os.pathsep)
    if len(raw_parts) == 1 and "," in value:
        raw_parts = value.split(",")

    normalized: list[Path] = []
    seen: set[Path] = set()
    for raw in raw_parts:
        token = raw.strip()
        if not token:
            continue
        path = Path(token).expanduser().resolve()
        if path not in seen:
            normalized.append(path)
            seen.add(path)
    return normalized


def project_dirs_to_env_value(paths: list[Path]) -> str:
    """Serialize project paths for env var storage."""
    return os.pathsep.join(str(path) for path in paths)


def parse_env_file(path: Path) -> dict[str, str]:
    """Parse KEY=VALUE lines from a simple env file."""
    if not path.exists() or not path.is_file():
        return {}

    payload: dict[str, str] = {}
    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        key = key.strip()
        value = value.strip()
        if (
            len(value) >= 2
            and ((value[0] == '"' and value[-1] == '"') or (value[0] == "'" and value[-1] == "'"))
        ):
            value = value[1:-1]
        payload[key] = value
    return payload


def quote_env_value(value: str) -> str:
    """Quote env values when needed to preserve whitespace/special chars."""
    if ENV_SAFE_VALUE_RE.fullmatch(value):
        return value
    escaped = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'"{escaped}"'


def write_env_file(path: Path, values: dict[str, str]) -> None:
    """Write deterministic Ralph env file with user-only permissions."""
    path.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "# Ralph Dashboard runtime configuration",
        "# Generated by `ralph-dashboard init`.",
        "",
        f"RALPH_SECRET_KEY={quote_env_value(values['RALPH_SECRET_KEY'])}",
        f"RALPH_PROJECT_DIRS={quote_env_value(values['RALPH_PROJECT_DIRS'])}",
        f"RALPH_PORT={quote_env_value(values['RALPH_PORT'])}",
        f"RALPH_CREDENTIALS_FILE={quote_env_value(values['RALPH_CREDENTIALS_FILE'])}",
        "",
    ]
    path.write_text("\n".join(lines), encoding="utf-8")
    path.chmod(S_IRUSR | S_IWUSR)


def read_credentials_username(path: Path) -> str | None:
    """Read username from credentials file if present."""
    if not path.exists() or not path.is_file():
        return None
    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if line.startswith("username:"):
            _, value = line.split(":", 1)
            username = value.strip()
            return username if username else None
    return None


def prompt_with_default(label: str, default: str) -> str:
    """Prompt for a value with a default fallback."""
    raw = input(f"{label} [{default}]: ").strip()
    return raw or default


def detect_project_dirs_from_env(env: dict[str, str]) -> list[Path]:
    """Resolve project dir list from env map or defaults."""
    raw = env.get("RALPH_PROJECT_DIRS", project_dirs_to_env_value(DEFAULT_PROJECT_DIRS))
    parsed = parse_project_dirs(raw)
    return parsed if parsed else DEFAULT_PROJECT_DIRS


def run_init(args: argparse.Namespace) -> int:
    """Interactive initialization workflow for local installs."""
    env_file = Path(args.env_file).expanduser().resolve()
    existing_env = parse_env_file(env_file)

    if env_file.exists() and not args.force:
        print(f"Env file already exists: {env_file}")
        print("Use --force to overwrite or edit the file manually.")
        return 1

    default_dirs = project_dirs_to_env_value(detect_project_dirs_from_env(existing_env))
    project_dirs_raw = args.project_dirs if args.project_dirs else prompt_with_default("Project directories", default_dirs)
    project_dirs = parse_project_dirs(project_dirs_raw)
    if not project_dirs:
        print("Error: at least one project directory is required.")
        return 1

    default_port = str(args.port or existing_env.get("RALPH_PORT", DEFAULT_PORT))
    port_text = str(args.port) if args.port else prompt_with_default("Dashboard port", default_port)
    try:
        port = int(port_text)
    except ValueError:
        print("Error: port must be an integer.")
        return 1
    if port < 1 or port > 65535:
        print("Error: port must be between 1 and 65535.")
        return 1

    credentials_path = Path(
        args.credentials_file or existing_env.get("RALPH_CREDENTIALS_FILE", str(DEFAULT_CREDENTIALS_FILE))
    ).expanduser().resolve()
    if credentials_path.exists() and not args.force:
        print(f"Credentials file already exists: {credentials_path}")
        print("Use --force to overwrite or provide --credentials-file.")
        return 1

    existing_username = read_credentials_username(credentials_path)
    default_username = args.username or existing_username or getpass.getuser()
    username = args.username if args.username else prompt_with_default("Dashboard username", default_username)
    username = username.strip()
    if not username:
        print("Error: username cannot be empty.")
        return 1

    password = args.password
    password_confirm = args.password_confirm
    if password is None:
        password = getpass.getpass("Dashboard password: ")
        password_confirm = getpass.getpass("Confirm password: ")
    elif password_confirm is None:
        password_confirm = password

    if not password:
        print("Error: password cannot be empty.")
        return 1
    if password != password_confirm:
        print("Error: password confirmation does not match.")
        return 1

    secret_key = args.secret_key or existing_env.get("RALPH_SECRET_KEY") or secrets.token_urlsafe(48)

    credentials_path.parent.mkdir(parents=True, exist_ok=True)
    write_credentials_file(credentials_path, username, hash_password(password))

    env_values = {
        "RALPH_SECRET_KEY": secret_key,
        "RALPH_PROJECT_DIRS": project_dirs_to_env_value(project_dirs),
        "RALPH_PORT": str(port),
        "RALPH_CREDENTIALS_FILE": str(credentials_path),
    }
    write_env_file(env_file, env_values)

    print("")
    print(f"{CHECK_MARK} Wrote env file: {env_file}")
    print(f"{CHECK_MARK} Wrote credentials: {credentials_path}")
    print("")
    print("Next steps:")
    print("1. Run: ralph-dashboard doctor")
    print("2. Install service: ralph-dashboard service install --user --start")
    print("3. Open: http://127.0.0.1:{port}".format(port=port))
    return 0


def discover_frontend_dist() -> Path | None:
    """Find usable frontend dist directory."""
    override = os.getenv("RALPH_FRONTEND_DIST")
    if override:
        candidate = Path(override).expanduser().resolve()
        if (candidate / "index.html").exists():
            return candidate

    for candidate in (default_packaged_frontend_dist(), default_dev_frontend_dist()):
        if (candidate / "index.html").exists():
            return candidate
    return None


def check_binary(name: str) -> str | None:
    """Return resolved path for binary when available."""
    return shutil.which(name)


def build_doctor_checks(env_file: Path) -> list[CheckResult]:
    """Evaluate installation/runtime checks with remediation hints."""
    results: list[CheckResult] = []
    env_values = parse_env_file(env_file)
    effective_env = {**env_values, **os.environ}

    python_ok = sys.version_info >= MIN_PYTHON_VERSION
    results.append(
        CheckResult(
            name="Python",
            ok=python_ok,
            message=f"Detected {sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
            fix="Install Python 3.12+ and re-run scripts/install.sh",
        )
    )

    git_path = check_binary("git")
    results.append(
        CheckResult(
            name="Git",
            ok=git_path is not None,
            message=git_path or "git not found on PATH",
            fix="Install git and ensure it is on PATH.",
        )
    )

    uvicorn_exec = backend_dir() / ".venv" / "bin" / "uvicorn"
    results.append(
        CheckResult(
            name="Backend venv",
            ok=uvicorn_exec.exists(),
            message=str(uvicorn_exec) if uvicorn_exec.exists() else "backend/.venv not initialized",
            fix="Run scripts/install.sh to create venv and install dependencies.",
        )
    )

    frontend_dist = discover_frontend_dist()
    results.append(
        CheckResult(
            name="Frontend assets",
            ok=frontend_dist is not None,
            message=str(frontend_dist) if frontend_dist else "No frontend dist found",
            fix="Build frontend (`cd frontend && npm run build`) or package dist into backend/app/static/dist.",
        )
    )

    results.append(
        CheckResult(
            name="Env file",
            ok=env_file.exists(),
            message=str(env_file) if env_file.exists() else "Missing env file",
            fix="Run `ralph-dashboard init` to generate it.",
        )
    )

    secret_key = effective_env.get("RALPH_SECRET_KEY", "").strip()
    results.append(
        CheckResult(
            name="RALPH_SECRET_KEY",
            ok=len(secret_key) >= 32 and secret_key != "replace-this-secret-key",
            message="Configured" if secret_key else "Missing",
            fix="Run `ralph-dashboard init` or set RALPH_SECRET_KEY in env file.",
        )
    )

    credentials_path = Path(
        effective_env.get("RALPH_CREDENTIALS_FILE", str(DEFAULT_CREDENTIALS_FILE))
    ).expanduser().resolve()
    results.append(
        CheckResult(
            name="Credentials file",
            ok=credentials_path.exists(),
            message=str(credentials_path) if credentials_path.exists() else "Missing credentials file",
            fix="Run `ralph-dashboard init` to create credentials.",
        )
    )

    raw_project_dirs = effective_env.get("RALPH_PROJECT_DIRS", "")
    project_dirs = parse_project_dirs(raw_project_dirs) if raw_project_dirs else []
    if project_dirs:
        missing = [path for path in project_dirs if not path.exists()]
        if missing:
            results.append(
                CheckResult(
                    name="Project directories",
                    ok=False,
                    message=", ".join(str(path) for path in missing),
                    fix="Create missing directories or update RALPH_PROJECT_DIRS.",
                )
            )
        else:
            results.append(
                CheckResult(
                    name="Project directories",
                    ok=True,
                    message=", ".join(str(path) for path in project_dirs),
                )
            )
    else:
        results.append(
            CheckResult(
                name="Project directories",
                ok=False,
                message="RALPH_PROJECT_DIRS is not configured",
                fix="Run `ralph-dashboard init` and provide project roots.",
            )
        )

    codex_path = check_binary("codex")
    claude_path = check_binary("claude")
    if codex_path or claude_path:
        details = []
        if codex_path:
            details.append(f"codex: {codex_path}")
        if claude_path:
            details.append(f"claude: {claude_path}")
        results.append(CheckResult(name="Agent CLIs", ok=True, message="; ".join(details)))
    else:
        results.append(
            CheckResult(
                name="Agent CLIs",
                ok=False,
                warning=True,
                message="Neither `codex` nor `claude` found",
                fix="Install at least one coding CLI to run Ralph loops.",
            )
        )

    openclaw_path = check_binary("openclaw")
    results.append(
        CheckResult(
            name="OpenClaw",
            ok=openclaw_path is not None,
            warning=True,
            message=openclaw_path or "Not installed (optional)",
            fix="Install OpenClaw to enable automated notification triage.",
        )
    )

    return results


def run_doctor(args: argparse.Namespace) -> int:
    """Print diagnostics for current installation and runtime setup."""
    env_file = Path(args.env_file).expanduser().resolve()
    checks = build_doctor_checks(env_file)

    print("Ralph Dashboard Doctor")
    print("======================")
    for check in checks:
        print(f"{check.marker} {check.name}: {check.message}")
        if not check.ok and check.fix:
            print(f"      Fix: {check.fix}")

    hard_failures = [check for check in checks if not check.ok and not check.warning]
    if hard_failures:
        print("")
        print(f"{FAIL_MARK} Doctor found {len(hard_failures)} blocking issue(s).")
        return 1

    warnings = [check for check in checks if not check.ok and check.warning]
    if warnings:
        print("")
        print(f"{WARN_MARK} Doctor completed with {len(warnings)} warning(s).")
    else:
        print("")
        print(f"{CHECK_MARK} Doctor passed.")
    return 0


def render_systemd_service_unit(
    *,
    service_name: str,
    backend_path: Path,
    env_file: Path,
    port: int,
) -> str:
    """Render systemd user unit content for Ralph Dashboard."""
    uvicorn_exec = backend_path / ".venv" / "bin" / "uvicorn"
    return "\n".join(
        [
            "[Unit]",
            "Description=Ralph Dashboard",
            "After=network.target",
            "",
            "[Service]",
            "Type=simple",
            f"WorkingDirectory={backend_path}",
            f"EnvironmentFile={env_file}",
            f"ExecStart={uvicorn_exec} app.main:app --host 127.0.0.1 --port {port}",
            "Restart=on-failure",
            "RestartSec=3",
            "",
            "[Install]",
            "WantedBy=default.target",
            "",
        ]
    )


def run_command(command: list[str], *, check: bool = True) -> subprocess.CompletedProcess[str]:
    """Run subprocess command with text output for operator feedback."""
    return subprocess.run(command, check=check, text=True, capture_output=True)


def ensure_systemd_user_available() -> tuple[bool, str]:
    """Check whether user-level systemd control is available."""
    if sys.platform != "linux":
        return False, "systemd user services are only supported on Linux."
    if check_binary("systemctl") is None:
        return False, "`systemctl` not found on PATH."
    return True, ""


def run_service_install(args: argparse.Namespace) -> int:
    """Install/update Ralph Dashboard systemd user service."""
    ok, reason = ensure_systemd_user_available()
    if not ok:
        print(f"Error: {reason}")
        return 1

    env_file = Path(args.env_file).expanduser().resolve()
    if not env_file.exists():
        print(f"Error: env file not found: {env_file}")
        print("Run `ralph-dashboard init` first.")
        return 1

    env_values = parse_env_file(env_file)
    port_text = str(args.port) if args.port is not None else env_values.get("RALPH_PORT", str(DEFAULT_PORT))
    try:
        port = int(port_text)
    except ValueError:
        print(f"Error: invalid port value '{port_text}'.")
        return 1

    service_name = args.service_name
    user_systemd_dir = Path.home() / ".config" / "systemd" / "user"
    user_systemd_dir.mkdir(parents=True, exist_ok=True)
    unit_path = user_systemd_dir / f"{service_name}.service"
    unit_content = render_systemd_service_unit(
        service_name=service_name,
        backend_path=backend_dir(),
        env_file=env_file,
        port=port,
    )
    unit_path.write_text(unit_content, encoding="utf-8")

    try:
        run_command(["systemctl", "--user", "daemon-reload"])
        if args.enable:
            run_command(["systemctl", "--user", "enable", f"{service_name}.service"])
        if args.start:
            run_command(["systemctl", "--user", "restart", f"{service_name}.service"])
    except subprocess.CalledProcessError as exc:
        print("Error: failed to configure systemd user service.")
        if exc.stderr:
            print(exc.stderr.strip())
        return 1

    print(f"{CHECK_MARK} Wrote service unit: {unit_path}")
    if args.enable:
        print(f"{CHECK_MARK} Enabled {service_name}.service")
    if args.start:
        print(f"{CHECK_MARK} Started {service_name}.service")
    print("")
    print(f"Use `ralph-dashboard service status --service-name {service_name}` to inspect state.")
    return 0


def run_service_control(args: argparse.Namespace) -> int:
    """Run service lifecycle commands through systemctl/journalctl."""
    ok, reason = ensure_systemd_user_available()
    if not ok:
        print(f"Error: {reason}")
        return 1

    unit = f"{args.service_name}.service"
    if args.service_command == "start":
        command = ["systemctl", "--user", "start", unit]
    elif args.service_command == "stop":
        command = ["systemctl", "--user", "stop", unit]
    elif args.service_command == "status":
        command = ["systemctl", "--user", "status", unit, "--no-pager"]
    elif args.service_command == "logs":
        command = ["journalctl", "--user", "-u", unit, "--no-pager", "-n", str(args.lines)]
        if args.follow:
            command.append("-f")
    else:
        print(f"Error: unsupported service command '{args.service_command}'.")
        return 1

    result = subprocess.run(command, check=False)
    return result.returncode


def build_parser() -> argparse.ArgumentParser:
    """Build top-level argparse parser."""
    parser = argparse.ArgumentParser(prog="ralph-dashboard", description="Ralph Dashboard operations CLI")
    subparsers = parser.add_subparsers(dest="command", required=True)

    init_parser = subparsers.add_parser("init", help="Initialize env + credentials interactively")
    init_parser.add_argument("--project-dirs", help=f"Project roots (pathsep/comma separated). Default: {DEFAULT_PROJECT_DIRS[0]}")
    init_parser.add_argument("--port", type=int, help=f"Dashboard port (default: {DEFAULT_PORT})")
    init_parser.add_argument("--username", help="Dashboard username")
    init_parser.add_argument("--password", help="Dashboard password")
    init_parser.add_argument("--password-confirm", help="Password confirmation for non-interactive use")
    init_parser.add_argument("--credentials-file", help=f"Credentials file path (default: {DEFAULT_CREDENTIALS_FILE})")
    init_parser.add_argument("--env-file", default=str(DEFAULT_ENV_FILE), help=f"Env file path (default: {DEFAULT_ENV_FILE})")
    init_parser.add_argument("--secret-key", help="Explicit secret key (otherwise generated)")
    init_parser.add_argument("--force", action="store_true", help="Overwrite existing env/credentials files")
    init_parser.set_defaults(handler=run_init)

    doctor_parser = subparsers.add_parser("doctor", help="Validate installation and runtime prerequisites")
    doctor_parser.add_argument("--env-file", default=str(DEFAULT_ENV_FILE), help=f"Env file path (default: {DEFAULT_ENV_FILE})")
    doctor_parser.set_defaults(handler=run_doctor)

    service_parser = subparsers.add_parser("service", help="Manage Ralph Dashboard systemd user service")
    service_subparsers = service_parser.add_subparsers(dest="service_command", required=True)

    install_parser = service_subparsers.add_parser("install", help="Install/update systemd user service")
    install_parser.add_argument("--user", action="store_true", help="Install as user service (default behavior)")
    install_parser.add_argument("--env-file", default=str(DEFAULT_ENV_FILE), help=f"Env file path (default: {DEFAULT_ENV_FILE})")
    install_parser.add_argument("--service-name", default=DEFAULT_SERVICE_NAME, help=f"Service base name (default: {DEFAULT_SERVICE_NAME})")
    install_parser.add_argument("--port", type=int, help="Override port baked into ExecStart")
    install_parser.add_argument("--enable", action=argparse.BooleanOptionalAction, default=True, help="Enable service after writing unit")
    install_parser.add_argument("--start", action=argparse.BooleanOptionalAction, default=True, help="Start/restart service after install")
    install_parser.set_defaults(handler=run_service_install)

    start_parser = service_subparsers.add_parser("start", help="Start service")
    start_parser.add_argument("--service-name", default=DEFAULT_SERVICE_NAME)
    start_parser.set_defaults(handler=run_service_control)

    stop_parser = service_subparsers.add_parser("stop", help="Stop service")
    stop_parser.add_argument("--service-name", default=DEFAULT_SERVICE_NAME)
    stop_parser.set_defaults(handler=run_service_control)

    status_parser = service_subparsers.add_parser("status", help="Show service status")
    status_parser.add_argument("--service-name", default=DEFAULT_SERVICE_NAME)
    status_parser.set_defaults(handler=run_service_control)

    logs_parser = service_subparsers.add_parser("logs", help="Show service logs")
    logs_parser.add_argument("--service-name", default=DEFAULT_SERVICE_NAME)
    logs_parser.add_argument("-n", "--lines", type=int, default=200, help="Number of lines to show")
    logs_parser.add_argument("-f", "--follow", action="store_true", help="Follow log output")
    logs_parser.set_defaults(handler=run_service_control)

    return parser


def main(argv: list[str] | None = None) -> int:
    """CLI entrypoint returning process exit code."""
    parser = build_parser()
    args = parser.parse_args(argv)
    handler = getattr(args, "handler", None)
    if handler is None:
        parser.print_help()
        return 1
    return int(handler(args))


def cli() -> None:
    """Console-script wrapper."""
    raise SystemExit(main())


if __name__ == "__main__":
    cli()

